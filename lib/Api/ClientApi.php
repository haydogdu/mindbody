<?php
/**
 * ClientApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * MINDBODY Public API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v6
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.6
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ClientApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ClientApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation clientAddArrival
     *
     * Add an arrival for a client.
     *
     * @param  \Swagger\Client\Model\AddArrivalRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AddArrivalResponse
     */
    public function clientAddArrival($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientAddArrivalWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientAddArrivalWithHttpInfo
     *
     * Add an arrival for a client.
     *
     * @param  \Swagger\Client\Model\AddArrivalRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AddArrivalResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientAddArrivalWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\AddArrivalResponse';
        $request = $this->clientAddArrivalRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AddArrivalResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientAddArrivalAsync
     *
     * Add an arrival for a client.
     *
     * @param  \Swagger\Client\Model\AddArrivalRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddArrivalAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientAddArrivalAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientAddArrivalAsyncWithHttpInfo
     *
     * Add an arrival for a client.
     *
     * @param  \Swagger\Client\Model\AddArrivalRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddArrivalAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\AddArrivalResponse';
        $request = $this->clientAddArrivalRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientAddArrival'
     *
     * @param  \Swagger\Client\Model\AddArrivalRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientAddArrivalRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientAddArrival'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientAddArrival'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientAddArrival'
            );
        }

        $resourcePath = '/public/v{version}/client/addarrival';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientAddClient
     *
     * Add a client to a site.
     *
     * @param  \Swagger\Client\Model\AddClientRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AddClientResponse
     */
    public function clientAddClient($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientAddClientWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientAddClientWithHttpInfo
     *
     * Add a client to a site.
     *
     * @param  \Swagger\Client\Model\AddClientRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AddClientResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientAddClientWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\AddClientResponse';
        $request = $this->clientAddClientRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AddClientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientAddClientAsync
     *
     * Add a client to a site.
     *
     * @param  \Swagger\Client\Model\AddClientRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddClientAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientAddClientAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientAddClientAsyncWithHttpInfo
     *
     * Add a client to a site.
     *
     * @param  \Swagger\Client\Model\AddClientRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddClientAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\AddClientResponse';
        $request = $this->clientAddClientRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientAddClient'
     *
     * @param  \Swagger\Client\Model\AddClientRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientAddClientRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientAddClient'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientAddClient'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientAddClient'
            );
        }

        $resourcePath = '/public/v{version}/client/addclient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientAddContactLog
     *
     * Add a contact log to a client's account.
     *
     * @param  \Swagger\Client\Model\AddContactLogRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContactLog
     */
    public function clientAddContactLog($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientAddContactLogWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientAddContactLogWithHttpInfo
     *
     * Add a contact log to a client's account.
     *
     * @param  \Swagger\Client\Model\AddContactLogRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContactLog, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientAddContactLogWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\ContactLog';
        $request = $this->clientAddContactLogRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContactLog',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientAddContactLogAsync
     *
     * Add a contact log to a client's account.
     *
     * @param  \Swagger\Client\Model\AddContactLogRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddContactLogAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientAddContactLogAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientAddContactLogAsyncWithHttpInfo
     *
     * Add a contact log to a client's account.
     *
     * @param  \Swagger\Client\Model\AddContactLogRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddContactLogAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\ContactLog';
        $request = $this->clientAddContactLogRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientAddContactLog'
     *
     * @param  \Swagger\Client\Model\AddContactLogRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientAddContactLogRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientAddContactLog'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientAddContactLog'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientAddContactLog'
            );
        }

        $resourcePath = '/public/v{version}/client/addcontactlog';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetActiveClientMemberships
     *
     * Get a client's active memberships.
     *
     * @param  string $request_client_id The ID of the client whose membership was requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_location_id The ID of the location where the requested membership was created. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetActiveClientMembershipsResponse
     */
    public function clientGetActiveClientMemberships($request_client_id, $site_id, $version, $authorization = '', $request_limit = null, $request_location_id = null, $request_offset = null)
    {
        list($response) = $this->clientGetActiveClientMembershipsWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_limit, $request_location_id, $request_offset);
        return $response;
    }

    /**
     * Operation clientGetActiveClientMembershipsWithHttpInfo
     *
     * Get a client's active memberships.
     *
     * @param  string $request_client_id The ID of the client whose membership was requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_location_id The ID of the location where the requested membership was created. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetActiveClientMembershipsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetActiveClientMembershipsWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_limit = null, $request_location_id = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetActiveClientMembershipsResponse';
        $request = $this->clientGetActiveClientMembershipsRequest($request_client_id, $site_id, $version, $authorization, $request_limit, $request_location_id, $request_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetActiveClientMembershipsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetActiveClientMembershipsAsync
     *
     * Get a client's active memberships.
     *
     * @param  string $request_client_id The ID of the client whose membership was requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_location_id The ID of the location where the requested membership was created. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetActiveClientMembershipsAsync($request_client_id, $site_id, $version, $authorization = '', $request_limit = null, $request_location_id = null, $request_offset = null)
    {
        return $this->clientGetActiveClientMembershipsAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_limit, $request_location_id, $request_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetActiveClientMembershipsAsyncWithHttpInfo
     *
     * Get a client's active memberships.
     *
     * @param  string $request_client_id The ID of the client whose membership was requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_location_id The ID of the location where the requested membership was created. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetActiveClientMembershipsAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_limit = null, $request_location_id = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetActiveClientMembershipsResponse';
        $request = $this->clientGetActiveClientMembershipsRequest($request_client_id, $site_id, $version, $authorization, $request_limit, $request_location_id, $request_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetActiveClientMemberships'
     *
     * @param  string $request_client_id The ID of the client whose membership was requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_location_id The ID of the location where the requested membership was created. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetActiveClientMembershipsRequest($request_client_id, $site_id, $version, $authorization = '', $request_limit = null, $request_location_id = null, $request_offset = null)
    {
        // verify the required parameter 'request_client_id' is set
        if ($request_client_id === null || (is_array($request_client_id) && count($request_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_client_id when calling clientGetActiveClientMemberships'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetActiveClientMemberships'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetActiveClientMemberships'
            );
        }

        $resourcePath = '/public/v{version}/client/activeclientmemberships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_client_id !== null) {
            $queryParams['request.clientId'] = ObjectSerializer::toQueryValue($request_client_id);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_location_id !== null) {
            $queryParams['request.locationId'] = ObjectSerializer::toQueryValue($request_location_id);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetClientAccountBalances
     *
     * Get account balance information for one or more client(s).
     *
     * @param  string[] $request_client_ids The list of clients IDs for which you want account balances. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_balance_date The date you want a balance relative to.   Default: **the current date** (optional)
     * @param  int $request_class_id The class ID of the event for which you want a balance. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetClientAccountBalancesResponse
     */
    public function clientGetClientAccountBalances($request_client_ids, $site_id, $version, $authorization = '', $request_balance_date = null, $request_class_id = null, $request_limit = null, $request_offset = null)
    {
        list($response) = $this->clientGetClientAccountBalancesWithHttpInfo($request_client_ids, $site_id, $version, $authorization, $request_balance_date, $request_class_id, $request_limit, $request_offset);
        return $response;
    }

    /**
     * Operation clientGetClientAccountBalancesWithHttpInfo
     *
     * Get account balance information for one or more client(s).
     *
     * @param  string[] $request_client_ids The list of clients IDs for which you want account balances. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_balance_date The date you want a balance relative to.   Default: **the current date** (optional)
     * @param  int $request_class_id The class ID of the event for which you want a balance. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetClientAccountBalancesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetClientAccountBalancesWithHttpInfo($request_client_ids, $site_id, $version, $authorization = '', $request_balance_date = null, $request_class_id = null, $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientAccountBalancesResponse';
        $request = $this->clientGetClientAccountBalancesRequest($request_client_ids, $site_id, $version, $authorization, $request_balance_date, $request_class_id, $request_limit, $request_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetClientAccountBalancesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetClientAccountBalancesAsync
     *
     * Get account balance information for one or more client(s).
     *
     * @param  string[] $request_client_ids The list of clients IDs for which you want account balances. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_balance_date The date you want a balance relative to.   Default: **the current date** (optional)
     * @param  int $request_class_id The class ID of the event for which you want a balance. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientAccountBalancesAsync($request_client_ids, $site_id, $version, $authorization = '', $request_balance_date = null, $request_class_id = null, $request_limit = null, $request_offset = null)
    {
        return $this->clientGetClientAccountBalancesAsyncWithHttpInfo($request_client_ids, $site_id, $version, $authorization, $request_balance_date, $request_class_id, $request_limit, $request_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetClientAccountBalancesAsyncWithHttpInfo
     *
     * Get account balance information for one or more client(s).
     *
     * @param  string[] $request_client_ids The list of clients IDs for which you want account balances. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_balance_date The date you want a balance relative to.   Default: **the current date** (optional)
     * @param  int $request_class_id The class ID of the event for which you want a balance. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientAccountBalancesAsyncWithHttpInfo($request_client_ids, $site_id, $version, $authorization = '', $request_balance_date = null, $request_class_id = null, $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientAccountBalancesResponse';
        $request = $this->clientGetClientAccountBalancesRequest($request_client_ids, $site_id, $version, $authorization, $request_balance_date, $request_class_id, $request_limit, $request_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetClientAccountBalances'
     *
     * @param  string[] $request_client_ids The list of clients IDs for which you want account balances. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_balance_date The date you want a balance relative to.   Default: **the current date** (optional)
     * @param  int $request_class_id The class ID of the event for which you want a balance. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetClientAccountBalancesRequest($request_client_ids, $site_id, $version, $authorization = '', $request_balance_date = null, $request_class_id = null, $request_limit = null, $request_offset = null)
    {
        // verify the required parameter 'request_client_ids' is set
        if ($request_client_ids === null || (is_array($request_client_ids) && count($request_client_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_client_ids when calling clientGetClientAccountBalances'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetClientAccountBalances'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetClientAccountBalances'
            );
        }

        $resourcePath = '/public/v{version}/client/clientaccountbalances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($request_client_ids)) {
            $request_client_ids = ObjectSerializer::serializeCollection($request_client_ids, 'multi', true);
        }
        if ($request_client_ids !== null) {
            $queryParams['request.clientIds'] = ObjectSerializer::toQueryValue($request_client_ids);
        }
        // query params
        if ($request_balance_date !== null) {
            $queryParams['request.balanceDate'] = ObjectSerializer::toQueryValue($request_balance_date);
        }
        // query params
        if ($request_class_id !== null) {
            $queryParams['request.classId'] = ObjectSerializer::toQueryValue($request_class_id);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetClientContracts
     *
     * Get contracts that a client has purchased.
     *
     * @param  string $request_client_id The ID of the client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset Determines how many sites are skipped over when retrieving a client’s cross regional contracts. Used when a client ID is linked to more than ten sites in an organization. Only a maximum of ten site databases are queried when this call is made and &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;. To change which sites are queried, change this offset value.  Default: **0** (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that the requesting client’s cross regional contracts are returned, if any.&lt;br /&gt;  When &#x60;false&#x60;, indicates that cross regional contracts are not returned. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetClientContractsResponse
     */
    public function clientGetClientContracts($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_limit = null, $request_offset = null)
    {
        list($response) = $this->clientGetClientContractsWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_limit, $request_offset);
        return $response;
    }

    /**
     * Operation clientGetClientContractsWithHttpInfo
     *
     * Get contracts that a client has purchased.
     *
     * @param  string $request_client_id The ID of the client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset Determines how many sites are skipped over when retrieving a client’s cross regional contracts. Used when a client ID is linked to more than ten sites in an organization. Only a maximum of ten site databases are queried when this call is made and &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;. To change which sites are queried, change this offset value.  Default: **0** (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that the requesting client’s cross regional contracts are returned, if any.&lt;br /&gt;  When &#x60;false&#x60;, indicates that cross regional contracts are not returned. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetClientContractsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetClientContractsWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientContractsResponse';
        $request = $this->clientGetClientContractsRequest($request_client_id, $site_id, $version, $authorization, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_limit, $request_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetClientContractsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetClientContractsAsync
     *
     * Get contracts that a client has purchased.
     *
     * @param  string $request_client_id The ID of the client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset Determines how many sites are skipped over when retrieving a client’s cross regional contracts. Used when a client ID is linked to more than ten sites in an organization. Only a maximum of ten site databases are queried when this call is made and &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;. To change which sites are queried, change this offset value.  Default: **0** (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that the requesting client’s cross regional contracts are returned, if any.&lt;br /&gt;  When &#x60;false&#x60;, indicates that cross regional contracts are not returned. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientContractsAsync($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_limit = null, $request_offset = null)
    {
        return $this->clientGetClientContractsAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_limit, $request_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetClientContractsAsyncWithHttpInfo
     *
     * Get contracts that a client has purchased.
     *
     * @param  string $request_client_id The ID of the client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset Determines how many sites are skipped over when retrieving a client’s cross regional contracts. Used when a client ID is linked to more than ten sites in an organization. Only a maximum of ten site databases are queried when this call is made and &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;. To change which sites are queried, change this offset value.  Default: **0** (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that the requesting client’s cross regional contracts are returned, if any.&lt;br /&gt;  When &#x60;false&#x60;, indicates that cross regional contracts are not returned. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientContractsAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientContractsResponse';
        $request = $this->clientGetClientContractsRequest($request_client_id, $site_id, $version, $authorization, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_limit, $request_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetClientContracts'
     *
     * @param  string $request_client_id The ID of the client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset Determines how many sites are skipped over when retrieving a client’s cross regional contracts. Used when a client ID is linked to more than ten sites in an organization. Only a maximum of ten site databases are queried when this call is made and &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;. To change which sites are queried, change this offset value.  Default: **0** (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that the requesting client’s cross regional contracts are returned, if any.&lt;br /&gt;  When &#x60;false&#x60;, indicates that cross regional contracts are not returned. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetClientContractsRequest($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_limit = null, $request_offset = null)
    {
        // verify the required parameter 'request_client_id' is set
        if ($request_client_id === null || (is_array($request_client_id) && count($request_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_client_id when calling clientGetClientContracts'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetClientContracts'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetClientContracts'
            );
        }

        $resourcePath = '/public/v{version}/client/clientcontracts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_client_id !== null) {
            $queryParams['request.clientId'] = ObjectSerializer::toQueryValue($request_client_id);
        }
        // query params
        if ($request_client_associated_sites_offset !== null) {
            $queryParams['request.clientAssociatedSitesOffset'] = ObjectSerializer::toQueryValue($request_client_associated_sites_offset);
        }
        // query params
        if ($request_cross_regional_lookup !== null) {
            $queryParams['request.crossRegionalLookup'] = ObjectSerializer::toQueryValue($request_cross_regional_lookup);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetClientFormulaNotes
     *
     * Get a client's formula notes.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_appointment_id The appointment ID of the appointment that the formula notes are related to. (optional)
     * @param  string $request_client_id The client ID of the client whose formula notes are being requested. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetClientFormulaNotesResponse
     */
    public function clientGetClientFormulaNotes($site_id, $version, $authorization = '', $request_appointment_id = null, $request_client_id = null, $request_limit = null, $request_offset = null)
    {
        list($response) = $this->clientGetClientFormulaNotesWithHttpInfo($site_id, $version, $authorization, $request_appointment_id, $request_client_id, $request_limit, $request_offset);
        return $response;
    }

    /**
     * Operation clientGetClientFormulaNotesWithHttpInfo
     *
     * Get a client's formula notes.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_appointment_id The appointment ID of the appointment that the formula notes are related to. (optional)
     * @param  string $request_client_id The client ID of the client whose formula notes are being requested. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetClientFormulaNotesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetClientFormulaNotesWithHttpInfo($site_id, $version, $authorization = '', $request_appointment_id = null, $request_client_id = null, $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientFormulaNotesResponse';
        $request = $this->clientGetClientFormulaNotesRequest($site_id, $version, $authorization, $request_appointment_id, $request_client_id, $request_limit, $request_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetClientFormulaNotesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetClientFormulaNotesAsync
     *
     * Get a client's formula notes.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_appointment_id The appointment ID of the appointment that the formula notes are related to. (optional)
     * @param  string $request_client_id The client ID of the client whose formula notes are being requested. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientFormulaNotesAsync($site_id, $version, $authorization = '', $request_appointment_id = null, $request_client_id = null, $request_limit = null, $request_offset = null)
    {
        return $this->clientGetClientFormulaNotesAsyncWithHttpInfo($site_id, $version, $authorization, $request_appointment_id, $request_client_id, $request_limit, $request_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetClientFormulaNotesAsyncWithHttpInfo
     *
     * Get a client's formula notes.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_appointment_id The appointment ID of the appointment that the formula notes are related to. (optional)
     * @param  string $request_client_id The client ID of the client whose formula notes are being requested. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientFormulaNotesAsyncWithHttpInfo($site_id, $version, $authorization = '', $request_appointment_id = null, $request_client_id = null, $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientFormulaNotesResponse';
        $request = $this->clientGetClientFormulaNotesRequest($site_id, $version, $authorization, $request_appointment_id, $request_client_id, $request_limit, $request_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetClientFormulaNotes'
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_appointment_id The appointment ID of the appointment that the formula notes are related to. (optional)
     * @param  string $request_client_id The client ID of the client whose formula notes are being requested. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetClientFormulaNotesRequest($site_id, $version, $authorization = '', $request_appointment_id = null, $request_client_id = null, $request_limit = null, $request_offset = null)
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetClientFormulaNotes'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetClientFormulaNotes'
            );
        }

        $resourcePath = '/public/v{version}/client/clientformulanotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_appointment_id !== null) {
            $queryParams['request.appointmentId'] = ObjectSerializer::toQueryValue($request_appointment_id);
        }
        // query params
        if ($request_client_id !== null) {
            $queryParams['request.clientId'] = ObjectSerializer::toQueryValue($request_client_id);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetClientIndexes
     *
     * Get a site's configured client indexes and client index values.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_required_only When &#x60;true&#x60;, filters the results to only indexes that are required on creation.&lt;br /&gt;  When &#x60;false&#x60; or omitted, returns all of the client indexes. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetClientIndexesResponse
     */
    public function clientGetClientIndexes($site_id, $version, $authorization = '', $request_required_only = null)
    {
        list($response) = $this->clientGetClientIndexesWithHttpInfo($site_id, $version, $authorization, $request_required_only);
        return $response;
    }

    /**
     * Operation clientGetClientIndexesWithHttpInfo
     *
     * Get a site's configured client indexes and client index values.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_required_only When &#x60;true&#x60;, filters the results to only indexes that are required on creation.&lt;br /&gt;  When &#x60;false&#x60; or omitted, returns all of the client indexes. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetClientIndexesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetClientIndexesWithHttpInfo($site_id, $version, $authorization = '', $request_required_only = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientIndexesResponse';
        $request = $this->clientGetClientIndexesRequest($site_id, $version, $authorization, $request_required_only);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetClientIndexesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetClientIndexesAsync
     *
     * Get a site's configured client indexes and client index values.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_required_only When &#x60;true&#x60;, filters the results to only indexes that are required on creation.&lt;br /&gt;  When &#x60;false&#x60; or omitted, returns all of the client indexes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientIndexesAsync($site_id, $version, $authorization = '', $request_required_only = null)
    {
        return $this->clientGetClientIndexesAsyncWithHttpInfo($site_id, $version, $authorization, $request_required_only)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetClientIndexesAsyncWithHttpInfo
     *
     * Get a site's configured client indexes and client index values.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_required_only When &#x60;true&#x60;, filters the results to only indexes that are required on creation.&lt;br /&gt;  When &#x60;false&#x60; or omitted, returns all of the client indexes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientIndexesAsyncWithHttpInfo($site_id, $version, $authorization = '', $request_required_only = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientIndexesResponse';
        $request = $this->clientGetClientIndexesRequest($site_id, $version, $authorization, $request_required_only);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetClientIndexes'
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_required_only When &#x60;true&#x60;, filters the results to only indexes that are required on creation.&lt;br /&gt;  When &#x60;false&#x60; or omitted, returns all of the client indexes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetClientIndexesRequest($site_id, $version, $authorization = '', $request_required_only = null)
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetClientIndexes'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetClientIndexes'
            );
        }

        $resourcePath = '/public/v{version}/client/clientindexes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_required_only !== null) {
            $queryParams['request.requiredOnly'] = ObjectSerializer::toQueryValue($request_required_only);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetClientPurchases
     *
     * Get a client's purchase history.
     *
     * @param  string $request_client_id The ID of the client you are querying for purchases. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters results to purchases made before this timestamp.&lt;br /&gt;  Default: **end of today** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int $request_sale_id Filters results to the single record associated with this ID. (optional)
     * @param  \DateTime $request_start_date Filters results to purchases made on or after this timestamp.&lt;br /&gt;  Default: **now** (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetClientPurchasesResponse
     */
    public function clientGetClientPurchases($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_sale_id = null, $request_start_date = null)
    {
        list($response) = $this->clientGetClientPurchasesWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_end_date, $request_limit, $request_offset, $request_sale_id, $request_start_date);
        return $response;
    }

    /**
     * Operation clientGetClientPurchasesWithHttpInfo
     *
     * Get a client's purchase history.
     *
     * @param  string $request_client_id The ID of the client you are querying for purchases. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters results to purchases made before this timestamp.&lt;br /&gt;  Default: **end of today** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int $request_sale_id Filters results to the single record associated with this ID. (optional)
     * @param  \DateTime $request_start_date Filters results to purchases made on or after this timestamp.&lt;br /&gt;  Default: **now** (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetClientPurchasesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetClientPurchasesWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_sale_id = null, $request_start_date = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientPurchasesResponse';
        $request = $this->clientGetClientPurchasesRequest($request_client_id, $site_id, $version, $authorization, $request_end_date, $request_limit, $request_offset, $request_sale_id, $request_start_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetClientPurchasesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetClientPurchasesAsync
     *
     * Get a client's purchase history.
     *
     * @param  string $request_client_id The ID of the client you are querying for purchases. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters results to purchases made before this timestamp.&lt;br /&gt;  Default: **end of today** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int $request_sale_id Filters results to the single record associated with this ID. (optional)
     * @param  \DateTime $request_start_date Filters results to purchases made on or after this timestamp.&lt;br /&gt;  Default: **now** (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientPurchasesAsync($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_sale_id = null, $request_start_date = null)
    {
        return $this->clientGetClientPurchasesAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_end_date, $request_limit, $request_offset, $request_sale_id, $request_start_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetClientPurchasesAsyncWithHttpInfo
     *
     * Get a client's purchase history.
     *
     * @param  string $request_client_id The ID of the client you are querying for purchases. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters results to purchases made before this timestamp.&lt;br /&gt;  Default: **end of today** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int $request_sale_id Filters results to the single record associated with this ID. (optional)
     * @param  \DateTime $request_start_date Filters results to purchases made on or after this timestamp.&lt;br /&gt;  Default: **now** (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientPurchasesAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_sale_id = null, $request_start_date = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientPurchasesResponse';
        $request = $this->clientGetClientPurchasesRequest($request_client_id, $site_id, $version, $authorization, $request_end_date, $request_limit, $request_offset, $request_sale_id, $request_start_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetClientPurchases'
     *
     * @param  string $request_client_id The ID of the client you are querying for purchases. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters results to purchases made before this timestamp.&lt;br /&gt;  Default: **end of today** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int $request_sale_id Filters results to the single record associated with this ID. (optional)
     * @param  \DateTime $request_start_date Filters results to purchases made on or after this timestamp.&lt;br /&gt;  Default: **now** (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetClientPurchasesRequest($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_sale_id = null, $request_start_date = null)
    {
        // verify the required parameter 'request_client_id' is set
        if ($request_client_id === null || (is_array($request_client_id) && count($request_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_client_id when calling clientGetClientPurchases'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetClientPurchases'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetClientPurchases'
            );
        }

        $resourcePath = '/public/v{version}/client/clientpurchases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_client_id !== null) {
            $queryParams['request.clientId'] = ObjectSerializer::toQueryValue($request_client_id);
        }
        // query params
        if ($request_end_date !== null) {
            $queryParams['request.endDate'] = ObjectSerializer::toQueryValue($request_end_date);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // query params
        if ($request_sale_id !== null) {
            $queryParams['request.saleId'] = ObjectSerializer::toQueryValue($request_sale_id);
        }
        // query params
        if ($request_start_date !== null) {
            $queryParams['request.startDate'] = ObjectSerializer::toQueryValue($request_start_date);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetClientReferralTypes
     *
     * Get a site's configured client referral types.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_include_inactive When &#x60;true&#x60;, filters the results to include subtypes and inactive referral types.&lt;br /&gt;  When &#x60;false&#x60;, includes no subtypes and only active types. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetClientReferralTypesResponse
     */
    public function clientGetClientReferralTypes($site_id, $version, $authorization = '', $request_include_inactive = null)
    {
        list($response) = $this->clientGetClientReferralTypesWithHttpInfo($site_id, $version, $authorization, $request_include_inactive);
        return $response;
    }

    /**
     * Operation clientGetClientReferralTypesWithHttpInfo
     *
     * Get a site's configured client referral types.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_include_inactive When &#x60;true&#x60;, filters the results to include subtypes and inactive referral types.&lt;br /&gt;  When &#x60;false&#x60;, includes no subtypes and only active types. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetClientReferralTypesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetClientReferralTypesWithHttpInfo($site_id, $version, $authorization = '', $request_include_inactive = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientReferralTypesResponse';
        $request = $this->clientGetClientReferralTypesRequest($site_id, $version, $authorization, $request_include_inactive);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetClientReferralTypesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetClientReferralTypesAsync
     *
     * Get a site's configured client referral types.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_include_inactive When &#x60;true&#x60;, filters the results to include subtypes and inactive referral types.&lt;br /&gt;  When &#x60;false&#x60;, includes no subtypes and only active types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientReferralTypesAsync($site_id, $version, $authorization = '', $request_include_inactive = null)
    {
        return $this->clientGetClientReferralTypesAsyncWithHttpInfo($site_id, $version, $authorization, $request_include_inactive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetClientReferralTypesAsyncWithHttpInfo
     *
     * Get a site's configured client referral types.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_include_inactive When &#x60;true&#x60;, filters the results to include subtypes and inactive referral types.&lt;br /&gt;  When &#x60;false&#x60;, includes no subtypes and only active types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientReferralTypesAsyncWithHttpInfo($site_id, $version, $authorization = '', $request_include_inactive = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientReferralTypesResponse';
        $request = $this->clientGetClientReferralTypesRequest($site_id, $version, $authorization, $request_include_inactive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetClientReferralTypes'
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  bool $request_include_inactive When &#x60;true&#x60;, filters the results to include subtypes and inactive referral types.&lt;br /&gt;  When &#x60;false&#x60;, includes no subtypes and only active types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetClientReferralTypesRequest($site_id, $version, $authorization = '', $request_include_inactive = null)
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetClientReferralTypes'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetClientReferralTypes'
            );
        }

        $resourcePath = '/public/v{version}/client/clientreferraltypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_include_inactive !== null) {
            $queryParams['request.includeInactive'] = ObjectSerializer::toQueryValue($request_include_inactive);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetClientServices
     *
     * Get pricing options that a client has purchased.
     *
     * @param  string $request_client_id The ID of the client to query. The results are a list of pricing options that the client has purchased. Note that “service” and “pricing option” are synonymous in this section of the documentation. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_class_id Filters results to only those pricing options that can be used to pay for this class. (optional)
     * @param  int $request_client_associated_sites_offset Used to retrieve a client’s pricing options from multiple sites within an organization when the client is associated with more than ten sites. To change which ten sites are searched, change this offset value. A value of 0 means that no sites are skipped and the first ten sites are returned. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that you must always have &#x60;CrossRegionalLookup&#x60; set to &#x60;true&#x60; to use this parameter.&lt;br /&gt;  Default: **0**    For example, if a client is associated with 25 sites, you need to call &#x60;GetClientServices&#x60; three times, as follows:  * Use &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites a client is associated with, which tells you how many additional calls you need to make.  * Either omit &#x60;ClientAssociatedSitesOffset&#x60; or set it to 0 to return the client’s services (pricing options) from sites 1-10.  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 10 to return the client pricing options from sites 11-20  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 20 to return the client pricing options from sites 21-25 (optional)
     * @param  bool $request_cross_regional_lookup Used to retrieve a client’s pricing options from multiple sites within an organization. When included and set to &#x60;true&#x60;, it searches a maximum of ten sites with which this client is associated. When a client is associated with more than ten sites, use &#x60;ClientAssociatedSitesOffset&#x60; as many times as needed to search the additional sites with which the client is associated. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that a &#x60;SiteID&#x60; is returned and populated in the &#x60;ClientServices&#x60; response when &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;.  Default: **false** (optional)
     * @param  \DateTime $request_end_date Filters results to pricing options that are valid on or before this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int[] $request_location_ids Filters results to pricing options that can be used at the listed location IDs. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int[] $request_program_ids Filters results to pricing options that belong to one of the given program IDs. (optional)
     * @param  int $request_session_type_id Filters results to pricing options that will pay for the given session type ID. Use this to find pricing options that will pay for a specific appointment type. (optional)
     * @param  bool $request_show_active_only When &#x60;true&#x60;, includes active services only.  Default: **false** (optional)
     * @param  \DateTime $request_start_date Filters results to pricing options that are valid on or after this date. (optional)
     * @param  int $request_visit_count A filter on the minimum number of visits a service can pay for. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetClientServicesResponse
     */
    public function clientGetClientServices($request_client_id, $site_id, $version, $authorization = '', $request_class_id = null, $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_location_ids = null, $request_offset = null, $request_program_ids = null, $request_session_type_id = null, $request_show_active_only = null, $request_start_date = null, $request_visit_count = null)
    {
        list($response) = $this->clientGetClientServicesWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_class_id, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_end_date, $request_limit, $request_location_ids, $request_offset, $request_program_ids, $request_session_type_id, $request_show_active_only, $request_start_date, $request_visit_count);
        return $response;
    }

    /**
     * Operation clientGetClientServicesWithHttpInfo
     *
     * Get pricing options that a client has purchased.
     *
     * @param  string $request_client_id The ID of the client to query. The results are a list of pricing options that the client has purchased. Note that “service” and “pricing option” are synonymous in this section of the documentation. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_class_id Filters results to only those pricing options that can be used to pay for this class. (optional)
     * @param  int $request_client_associated_sites_offset Used to retrieve a client’s pricing options from multiple sites within an organization when the client is associated with more than ten sites. To change which ten sites are searched, change this offset value. A value of 0 means that no sites are skipped and the first ten sites are returned. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that you must always have &#x60;CrossRegionalLookup&#x60; set to &#x60;true&#x60; to use this parameter.&lt;br /&gt;  Default: **0**    For example, if a client is associated with 25 sites, you need to call &#x60;GetClientServices&#x60; three times, as follows:  * Use &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites a client is associated with, which tells you how many additional calls you need to make.  * Either omit &#x60;ClientAssociatedSitesOffset&#x60; or set it to 0 to return the client’s services (pricing options) from sites 1-10.  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 10 to return the client pricing options from sites 11-20  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 20 to return the client pricing options from sites 21-25 (optional)
     * @param  bool $request_cross_regional_lookup Used to retrieve a client’s pricing options from multiple sites within an organization. When included and set to &#x60;true&#x60;, it searches a maximum of ten sites with which this client is associated. When a client is associated with more than ten sites, use &#x60;ClientAssociatedSitesOffset&#x60; as many times as needed to search the additional sites with which the client is associated. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that a &#x60;SiteID&#x60; is returned and populated in the &#x60;ClientServices&#x60; response when &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;.  Default: **false** (optional)
     * @param  \DateTime $request_end_date Filters results to pricing options that are valid on or before this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int[] $request_location_ids Filters results to pricing options that can be used at the listed location IDs. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int[] $request_program_ids Filters results to pricing options that belong to one of the given program IDs. (optional)
     * @param  int $request_session_type_id Filters results to pricing options that will pay for the given session type ID. Use this to find pricing options that will pay for a specific appointment type. (optional)
     * @param  bool $request_show_active_only When &#x60;true&#x60;, includes active services only.  Default: **false** (optional)
     * @param  \DateTime $request_start_date Filters results to pricing options that are valid on or after this date. (optional)
     * @param  int $request_visit_count A filter on the minimum number of visits a service can pay for. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetClientServicesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetClientServicesWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_class_id = null, $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_location_ids = null, $request_offset = null, $request_program_ids = null, $request_session_type_id = null, $request_show_active_only = null, $request_start_date = null, $request_visit_count = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientServicesResponse';
        $request = $this->clientGetClientServicesRequest($request_client_id, $site_id, $version, $authorization, $request_class_id, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_end_date, $request_limit, $request_location_ids, $request_offset, $request_program_ids, $request_session_type_id, $request_show_active_only, $request_start_date, $request_visit_count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetClientServicesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetClientServicesAsync
     *
     * Get pricing options that a client has purchased.
     *
     * @param  string $request_client_id The ID of the client to query. The results are a list of pricing options that the client has purchased. Note that “service” and “pricing option” are synonymous in this section of the documentation. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_class_id Filters results to only those pricing options that can be used to pay for this class. (optional)
     * @param  int $request_client_associated_sites_offset Used to retrieve a client’s pricing options from multiple sites within an organization when the client is associated with more than ten sites. To change which ten sites are searched, change this offset value. A value of 0 means that no sites are skipped and the first ten sites are returned. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that you must always have &#x60;CrossRegionalLookup&#x60; set to &#x60;true&#x60; to use this parameter.&lt;br /&gt;  Default: **0**    For example, if a client is associated with 25 sites, you need to call &#x60;GetClientServices&#x60; three times, as follows:  * Use &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites a client is associated with, which tells you how many additional calls you need to make.  * Either omit &#x60;ClientAssociatedSitesOffset&#x60; or set it to 0 to return the client’s services (pricing options) from sites 1-10.  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 10 to return the client pricing options from sites 11-20  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 20 to return the client pricing options from sites 21-25 (optional)
     * @param  bool $request_cross_regional_lookup Used to retrieve a client’s pricing options from multiple sites within an organization. When included and set to &#x60;true&#x60;, it searches a maximum of ten sites with which this client is associated. When a client is associated with more than ten sites, use &#x60;ClientAssociatedSitesOffset&#x60; as many times as needed to search the additional sites with which the client is associated. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that a &#x60;SiteID&#x60; is returned and populated in the &#x60;ClientServices&#x60; response when &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;.  Default: **false** (optional)
     * @param  \DateTime $request_end_date Filters results to pricing options that are valid on or before this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int[] $request_location_ids Filters results to pricing options that can be used at the listed location IDs. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int[] $request_program_ids Filters results to pricing options that belong to one of the given program IDs. (optional)
     * @param  int $request_session_type_id Filters results to pricing options that will pay for the given session type ID. Use this to find pricing options that will pay for a specific appointment type. (optional)
     * @param  bool $request_show_active_only When &#x60;true&#x60;, includes active services only.  Default: **false** (optional)
     * @param  \DateTime $request_start_date Filters results to pricing options that are valid on or after this date. (optional)
     * @param  int $request_visit_count A filter on the minimum number of visits a service can pay for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientServicesAsync($request_client_id, $site_id, $version, $authorization = '', $request_class_id = null, $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_location_ids = null, $request_offset = null, $request_program_ids = null, $request_session_type_id = null, $request_show_active_only = null, $request_start_date = null, $request_visit_count = null)
    {
        return $this->clientGetClientServicesAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_class_id, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_end_date, $request_limit, $request_location_ids, $request_offset, $request_program_ids, $request_session_type_id, $request_show_active_only, $request_start_date, $request_visit_count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetClientServicesAsyncWithHttpInfo
     *
     * Get pricing options that a client has purchased.
     *
     * @param  string $request_client_id The ID of the client to query. The results are a list of pricing options that the client has purchased. Note that “service” and “pricing option” are synonymous in this section of the documentation. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_class_id Filters results to only those pricing options that can be used to pay for this class. (optional)
     * @param  int $request_client_associated_sites_offset Used to retrieve a client’s pricing options from multiple sites within an organization when the client is associated with more than ten sites. To change which ten sites are searched, change this offset value. A value of 0 means that no sites are skipped and the first ten sites are returned. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that you must always have &#x60;CrossRegionalLookup&#x60; set to &#x60;true&#x60; to use this parameter.&lt;br /&gt;  Default: **0**    For example, if a client is associated with 25 sites, you need to call &#x60;GetClientServices&#x60; three times, as follows:  * Use &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites a client is associated with, which tells you how many additional calls you need to make.  * Either omit &#x60;ClientAssociatedSitesOffset&#x60; or set it to 0 to return the client’s services (pricing options) from sites 1-10.  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 10 to return the client pricing options from sites 11-20  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 20 to return the client pricing options from sites 21-25 (optional)
     * @param  bool $request_cross_regional_lookup Used to retrieve a client’s pricing options from multiple sites within an organization. When included and set to &#x60;true&#x60;, it searches a maximum of ten sites with which this client is associated. When a client is associated with more than ten sites, use &#x60;ClientAssociatedSitesOffset&#x60; as many times as needed to search the additional sites with which the client is associated. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that a &#x60;SiteID&#x60; is returned and populated in the &#x60;ClientServices&#x60; response when &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;.  Default: **false** (optional)
     * @param  \DateTime $request_end_date Filters results to pricing options that are valid on or before this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int[] $request_location_ids Filters results to pricing options that can be used at the listed location IDs. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int[] $request_program_ids Filters results to pricing options that belong to one of the given program IDs. (optional)
     * @param  int $request_session_type_id Filters results to pricing options that will pay for the given session type ID. Use this to find pricing options that will pay for a specific appointment type. (optional)
     * @param  bool $request_show_active_only When &#x60;true&#x60;, includes active services only.  Default: **false** (optional)
     * @param  \DateTime $request_start_date Filters results to pricing options that are valid on or after this date. (optional)
     * @param  int $request_visit_count A filter on the minimum number of visits a service can pay for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientServicesAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_class_id = null, $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_location_ids = null, $request_offset = null, $request_program_ids = null, $request_session_type_id = null, $request_show_active_only = null, $request_start_date = null, $request_visit_count = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientServicesResponse';
        $request = $this->clientGetClientServicesRequest($request_client_id, $site_id, $version, $authorization, $request_class_id, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_end_date, $request_limit, $request_location_ids, $request_offset, $request_program_ids, $request_session_type_id, $request_show_active_only, $request_start_date, $request_visit_count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetClientServices'
     *
     * @param  string $request_client_id The ID of the client to query. The results are a list of pricing options that the client has purchased. Note that “service” and “pricing option” are synonymous in this section of the documentation. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_class_id Filters results to only those pricing options that can be used to pay for this class. (optional)
     * @param  int $request_client_associated_sites_offset Used to retrieve a client’s pricing options from multiple sites within an organization when the client is associated with more than ten sites. To change which ten sites are searched, change this offset value. A value of 0 means that no sites are skipped and the first ten sites are returned. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that you must always have &#x60;CrossRegionalLookup&#x60; set to &#x60;true&#x60; to use this parameter.&lt;br /&gt;  Default: **0**    For example, if a client is associated with 25 sites, you need to call &#x60;GetClientServices&#x60; three times, as follows:  * Use &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites a client is associated with, which tells you how many additional calls you need to make.  * Either omit &#x60;ClientAssociatedSitesOffset&#x60; or set it to 0 to return the client’s services (pricing options) from sites 1-10.  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 10 to return the client pricing options from sites 11-20  * Set &#x60;ClientAssociatedSitesOffset&#x60; to 20 to return the client pricing options from sites 21-25 (optional)
     * @param  bool $request_cross_regional_lookup Used to retrieve a client’s pricing options from multiple sites within an organization. When included and set to &#x60;true&#x60;, it searches a maximum of ten sites with which this client is associated. When a client is associated with more than ten sites, use &#x60;ClientAssociatedSitesOffset&#x60; as many times as needed to search the additional sites with which the client is associated. You can use the &#x60;CrossRegionalClientAssociations&#x60; value from &#x60;GET CrossRegionalClientAssociations&#x60; to determine how many sites the client is associated with. Note that a &#x60;SiteID&#x60; is returned and populated in the &#x60;ClientServices&#x60; response when &#x60;CrossRegionalLookup&#x60; is set to &#x60;true&#x60;.  Default: **false** (optional)
     * @param  \DateTime $request_end_date Filters results to pricing options that are valid on or before this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int[] $request_location_ids Filters results to pricing options that can be used at the listed location IDs. (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  int[] $request_program_ids Filters results to pricing options that belong to one of the given program IDs. (optional)
     * @param  int $request_session_type_id Filters results to pricing options that will pay for the given session type ID. Use this to find pricing options that will pay for a specific appointment type. (optional)
     * @param  bool $request_show_active_only When &#x60;true&#x60;, includes active services only.  Default: **false** (optional)
     * @param  \DateTime $request_start_date Filters results to pricing options that are valid on or after this date. (optional)
     * @param  int $request_visit_count A filter on the minimum number of visits a service can pay for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetClientServicesRequest($request_client_id, $site_id, $version, $authorization = '', $request_class_id = null, $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_location_ids = null, $request_offset = null, $request_program_ids = null, $request_session_type_id = null, $request_show_active_only = null, $request_start_date = null, $request_visit_count = null)
    {
        // verify the required parameter 'request_client_id' is set
        if ($request_client_id === null || (is_array($request_client_id) && count($request_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_client_id when calling clientGetClientServices'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetClientServices'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetClientServices'
            );
        }

        $resourcePath = '/public/v{version}/client/clientservices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_client_id !== null) {
            $queryParams['request.clientId'] = ObjectSerializer::toQueryValue($request_client_id);
        }
        // query params
        if ($request_class_id !== null) {
            $queryParams['request.classId'] = ObjectSerializer::toQueryValue($request_class_id);
        }
        // query params
        if ($request_client_associated_sites_offset !== null) {
            $queryParams['request.clientAssociatedSitesOffset'] = ObjectSerializer::toQueryValue($request_client_associated_sites_offset);
        }
        // query params
        if ($request_cross_regional_lookup !== null) {
            $queryParams['request.crossRegionalLookup'] = ObjectSerializer::toQueryValue($request_cross_regional_lookup);
        }
        // query params
        if ($request_end_date !== null) {
            $queryParams['request.endDate'] = ObjectSerializer::toQueryValue($request_end_date);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if (is_array($request_location_ids)) {
            $request_location_ids = ObjectSerializer::serializeCollection($request_location_ids, 'multi', true);
        }
        if ($request_location_ids !== null) {
            $queryParams['request.locationIds'] = ObjectSerializer::toQueryValue($request_location_ids);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // query params
        if (is_array($request_program_ids)) {
            $request_program_ids = ObjectSerializer::serializeCollection($request_program_ids, 'multi', true);
        }
        if ($request_program_ids !== null) {
            $queryParams['request.programIds'] = ObjectSerializer::toQueryValue($request_program_ids);
        }
        // query params
        if ($request_session_type_id !== null) {
            $queryParams['request.sessionTypeId'] = ObjectSerializer::toQueryValue($request_session_type_id);
        }
        // query params
        if ($request_show_active_only !== null) {
            $queryParams['request.showActiveOnly'] = ObjectSerializer::toQueryValue($request_show_active_only);
        }
        // query params
        if ($request_start_date !== null) {
            $queryParams['request.startDate'] = ObjectSerializer::toQueryValue($request_start_date);
        }
        // query params
        if ($request_visit_count !== null) {
            $queryParams['request.visitCount'] = ObjectSerializer::toQueryValue($request_visit_count);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetClientVisits
     *
     * Get a client's visit history.
     *
     * @param  string $request_client_id The ID of the requested client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset The number of sites to skip when returning the site associated with a client. (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that past and scheduled client visits across all sites in the region are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only visits at the current site are returned. (optional)
     * @param  \DateTime $request_end_date The date past which class visits are not returned.  Default: **today’s date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  \DateTime $request_start_date The date before which class visits are not returned.  Default: **the end date** (optional)
     * @param  bool $request_unpaids_only When &#x60;true&#x60;, indicates that only visits that have not been paid for are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that all visits are returned, regardless of whether they have been paid for.&lt;br /&gt;  Default: **false** (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetClientVisitsResponse
     */
    public function clientGetClientVisits($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_offset = null, $request_start_date = null, $request_unpaids_only = null)
    {
        list($response) = $this->clientGetClientVisitsWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_end_date, $request_limit, $request_offset, $request_start_date, $request_unpaids_only);
        return $response;
    }

    /**
     * Operation clientGetClientVisitsWithHttpInfo
     *
     * Get a client's visit history.
     *
     * @param  string $request_client_id The ID of the requested client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset The number of sites to skip when returning the site associated with a client. (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that past and scheduled client visits across all sites in the region are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only visits at the current site are returned. (optional)
     * @param  \DateTime $request_end_date The date past which class visits are not returned.  Default: **today’s date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  \DateTime $request_start_date The date before which class visits are not returned.  Default: **the end date** (optional)
     * @param  bool $request_unpaids_only When &#x60;true&#x60;, indicates that only visits that have not been paid for are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that all visits are returned, regardless of whether they have been paid for.&lt;br /&gt;  Default: **false** (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetClientVisitsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetClientVisitsWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_offset = null, $request_start_date = null, $request_unpaids_only = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientVisitsResponse';
        $request = $this->clientGetClientVisitsRequest($request_client_id, $site_id, $version, $authorization, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_end_date, $request_limit, $request_offset, $request_start_date, $request_unpaids_only);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetClientVisitsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetClientVisitsAsync
     *
     * Get a client's visit history.
     *
     * @param  string $request_client_id The ID of the requested client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset The number of sites to skip when returning the site associated with a client. (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that past and scheduled client visits across all sites in the region are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only visits at the current site are returned. (optional)
     * @param  \DateTime $request_end_date The date past which class visits are not returned.  Default: **today’s date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  \DateTime $request_start_date The date before which class visits are not returned.  Default: **the end date** (optional)
     * @param  bool $request_unpaids_only When &#x60;true&#x60;, indicates that only visits that have not been paid for are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that all visits are returned, regardless of whether they have been paid for.&lt;br /&gt;  Default: **false** (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientVisitsAsync($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_offset = null, $request_start_date = null, $request_unpaids_only = null)
    {
        return $this->clientGetClientVisitsAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_end_date, $request_limit, $request_offset, $request_start_date, $request_unpaids_only)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetClientVisitsAsyncWithHttpInfo
     *
     * Get a client's visit history.
     *
     * @param  string $request_client_id The ID of the requested client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset The number of sites to skip when returning the site associated with a client. (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that past and scheduled client visits across all sites in the region are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only visits at the current site are returned. (optional)
     * @param  \DateTime $request_end_date The date past which class visits are not returned.  Default: **today’s date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  \DateTime $request_start_date The date before which class visits are not returned.  Default: **the end date** (optional)
     * @param  bool $request_unpaids_only When &#x60;true&#x60;, indicates that only visits that have not been paid for are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that all visits are returned, regardless of whether they have been paid for.&lt;br /&gt;  Default: **false** (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientVisitsAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_offset = null, $request_start_date = null, $request_unpaids_only = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientVisitsResponse';
        $request = $this->clientGetClientVisitsRequest($request_client_id, $site_id, $version, $authorization, $request_client_associated_sites_offset, $request_cross_regional_lookup, $request_end_date, $request_limit, $request_offset, $request_start_date, $request_unpaids_only);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetClientVisits'
     *
     * @param  string $request_client_id The ID of the requested client. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_client_associated_sites_offset The number of sites to skip when returning the site associated with a client. (optional)
     * @param  bool $request_cross_regional_lookup When &#x60;true&#x60;, indicates that past and scheduled client visits across all sites in the region are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only visits at the current site are returned. (optional)
     * @param  \DateTime $request_end_date The date past which class visits are not returned.  Default: **today’s date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  \DateTime $request_start_date The date before which class visits are not returned.  Default: **the end date** (optional)
     * @param  bool $request_unpaids_only When &#x60;true&#x60;, indicates that only visits that have not been paid for are returned.&lt;br /&gt;  When &#x60;false&#x60;, indicates that all visits are returned, regardless of whether they have been paid for.&lt;br /&gt;  Default: **false** (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetClientVisitsRequest($request_client_id, $site_id, $version, $authorization = '', $request_client_associated_sites_offset = null, $request_cross_regional_lookup = null, $request_end_date = null, $request_limit = null, $request_offset = null, $request_start_date = null, $request_unpaids_only = null)
    {
        // verify the required parameter 'request_client_id' is set
        if ($request_client_id === null || (is_array($request_client_id) && count($request_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_client_id when calling clientGetClientVisits'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetClientVisits'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetClientVisits'
            );
        }

        $resourcePath = '/public/v{version}/client/clientvisits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_client_id !== null) {
            $queryParams['request.clientId'] = ObjectSerializer::toQueryValue($request_client_id);
        }
        // query params
        if ($request_client_associated_sites_offset !== null) {
            $queryParams['request.clientAssociatedSitesOffset'] = ObjectSerializer::toQueryValue($request_client_associated_sites_offset);
        }
        // query params
        if ($request_cross_regional_lookup !== null) {
            $queryParams['request.crossRegionalLookup'] = ObjectSerializer::toQueryValue($request_cross_regional_lookup);
        }
        // query params
        if ($request_end_date !== null) {
            $queryParams['request.endDate'] = ObjectSerializer::toQueryValue($request_end_date);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // query params
        if ($request_start_date !== null) {
            $queryParams['request.startDate'] = ObjectSerializer::toQueryValue($request_start_date);
        }
        // query params
        if ($request_unpaids_only !== null) {
            $queryParams['request.unpaidsOnly'] = ObjectSerializer::toQueryValue($request_unpaids_only);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetClients
     *
     * Get clients.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string[] $request_client_i_ds The requested client IDs.  Default: **all IDs** that the authenticated user’s access level allows. (optional)
     * @param  bool $request_is_prospect When &#x60;true&#x60;, filters the results to include only those clients marked as prospects for the business.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only those clients who are not marked prospects should be returned. (optional)
     * @param  \DateTime $request_last_modified_date Filters the results to include only the clients that have been modified on or after this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  string $request_search_text Text to use in the search. Can include FirstName, LastName, and Email. Note that user credentials must be provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetClientsResponse
     */
    public function clientGetClients($site_id, $version, $authorization = '', $request_client_i_ds = null, $request_is_prospect = null, $request_last_modified_date = null, $request_limit = null, $request_offset = null, $request_search_text = null)
    {
        list($response) = $this->clientGetClientsWithHttpInfo($site_id, $version, $authorization, $request_client_i_ds, $request_is_prospect, $request_last_modified_date, $request_limit, $request_offset, $request_search_text);
        return $response;
    }

    /**
     * Operation clientGetClientsWithHttpInfo
     *
     * Get clients.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string[] $request_client_i_ds The requested client IDs.  Default: **all IDs** that the authenticated user’s access level allows. (optional)
     * @param  bool $request_is_prospect When &#x60;true&#x60;, filters the results to include only those clients marked as prospects for the business.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only those clients who are not marked prospects should be returned. (optional)
     * @param  \DateTime $request_last_modified_date Filters the results to include only the clients that have been modified on or after this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  string $request_search_text Text to use in the search. Can include FirstName, LastName, and Email. Note that user credentials must be provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetClientsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetClientsWithHttpInfo($site_id, $version, $authorization = '', $request_client_i_ds = null, $request_is_prospect = null, $request_last_modified_date = null, $request_limit = null, $request_offset = null, $request_search_text = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientsResponse';
        $request = $this->clientGetClientsRequest($site_id, $version, $authorization, $request_client_i_ds, $request_is_prospect, $request_last_modified_date, $request_limit, $request_offset, $request_search_text);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetClientsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetClientsAsync
     *
     * Get clients.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string[] $request_client_i_ds The requested client IDs.  Default: **all IDs** that the authenticated user’s access level allows. (optional)
     * @param  bool $request_is_prospect When &#x60;true&#x60;, filters the results to include only those clients marked as prospects for the business.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only those clients who are not marked prospects should be returned. (optional)
     * @param  \DateTime $request_last_modified_date Filters the results to include only the clients that have been modified on or after this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  string $request_search_text Text to use in the search. Can include FirstName, LastName, and Email. Note that user credentials must be provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientsAsync($site_id, $version, $authorization = '', $request_client_i_ds = null, $request_is_prospect = null, $request_last_modified_date = null, $request_limit = null, $request_offset = null, $request_search_text = null)
    {
        return $this->clientGetClientsAsyncWithHttpInfo($site_id, $version, $authorization, $request_client_i_ds, $request_is_prospect, $request_last_modified_date, $request_limit, $request_offset, $request_search_text)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetClientsAsyncWithHttpInfo
     *
     * Get clients.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string[] $request_client_i_ds The requested client IDs.  Default: **all IDs** that the authenticated user’s access level allows. (optional)
     * @param  bool $request_is_prospect When &#x60;true&#x60;, filters the results to include only those clients marked as prospects for the business.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only those clients who are not marked prospects should be returned. (optional)
     * @param  \DateTime $request_last_modified_date Filters the results to include only the clients that have been modified on or after this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  string $request_search_text Text to use in the search. Can include FirstName, LastName, and Email. Note that user credentials must be provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetClientsAsyncWithHttpInfo($site_id, $version, $authorization = '', $request_client_i_ds = null, $request_is_prospect = null, $request_last_modified_date = null, $request_limit = null, $request_offset = null, $request_search_text = null)
    {
        $returnType = '\Swagger\Client\Model\GetClientsResponse';
        $request = $this->clientGetClientsRequest($site_id, $version, $authorization, $request_client_i_ds, $request_is_prospect, $request_last_modified_date, $request_limit, $request_offset, $request_search_text);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetClients'
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string[] $request_client_i_ds The requested client IDs.  Default: **all IDs** that the authenticated user’s access level allows. (optional)
     * @param  bool $request_is_prospect When &#x60;true&#x60;, filters the results to include only those clients marked as prospects for the business.&lt;br /&gt;  When &#x60;false&#x60;, indicates that only those clients who are not marked prospects should be returned. (optional)
     * @param  \DateTime $request_last_modified_date Filters the results to include only the clients that have been modified on or after this date. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  string $request_search_text Text to use in the search. Can include FirstName, LastName, and Email. Note that user credentials must be provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetClientsRequest($site_id, $version, $authorization = '', $request_client_i_ds = null, $request_is_prospect = null, $request_last_modified_date = null, $request_limit = null, $request_offset = null, $request_search_text = null)
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetClients'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetClients'
            );
        }

        $resourcePath = '/public/v{version}/client/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($request_client_i_ds)) {
            $request_client_i_ds = ObjectSerializer::serializeCollection($request_client_i_ds, 'multi', true);
        }
        if ($request_client_i_ds !== null) {
            $queryParams['request.clientIDs'] = ObjectSerializer::toQueryValue($request_client_i_ds);
        }
        // query params
        if ($request_is_prospect !== null) {
            $queryParams['request.isProspect'] = ObjectSerializer::toQueryValue($request_is_prospect);
        }
        // query params
        if ($request_last_modified_date !== null) {
            $queryParams['request.lastModifiedDate'] = ObjectSerializer::toQueryValue($request_last_modified_date);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // query params
        if ($request_search_text !== null) {
            $queryParams['request.searchText'] = ObjectSerializer::toQueryValue($request_search_text);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetContactLogs
     *
     * Get contact logs on a client's account.
     *
     * @param  string $request_client_id The ID of the client whose contact logs are being requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters the results to contact logs created before this date.&lt;br /&gt;  Default: **the start date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  bool $request_show_system_generated When &#x60;true&#x60;, system-generated contact logs are returned in the results.&lt;br /&gt;  Default: **false** (optional)
     * @param  int[] $request_staff_ids Filters the results to return contact logs assigned to one or more staff IDs. (optional)
     * @param  \DateTime $request_start_date Filters the results to contact logs created on or after this date.&lt;br /&gt;  Default: **the current date** (optional)
     * @param  int[] $request_subtype_ids Filters the results to contact logs assigned one or more of these subtype IDs. (optional)
     * @param  int[] $request_type_ids Filters the results to contact logs assigned one or more of these type IDs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetContactLogsResponse
     */
    public function clientGetContactLogs($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_show_system_generated = null, $request_staff_ids = null, $request_start_date = null, $request_subtype_ids = null, $request_type_ids = null)
    {
        list($response) = $this->clientGetContactLogsWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_end_date, $request_limit, $request_offset, $request_show_system_generated, $request_staff_ids, $request_start_date, $request_subtype_ids, $request_type_ids);
        return $response;
    }

    /**
     * Operation clientGetContactLogsWithHttpInfo
     *
     * Get contact logs on a client's account.
     *
     * @param  string $request_client_id The ID of the client whose contact logs are being requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters the results to contact logs created before this date.&lt;br /&gt;  Default: **the start date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  bool $request_show_system_generated When &#x60;true&#x60;, system-generated contact logs are returned in the results.&lt;br /&gt;  Default: **false** (optional)
     * @param  int[] $request_staff_ids Filters the results to return contact logs assigned to one or more staff IDs. (optional)
     * @param  \DateTime $request_start_date Filters the results to contact logs created on or after this date.&lt;br /&gt;  Default: **the current date** (optional)
     * @param  int[] $request_subtype_ids Filters the results to contact logs assigned one or more of these subtype IDs. (optional)
     * @param  int[] $request_type_ids Filters the results to contact logs assigned one or more of these type IDs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetContactLogsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetContactLogsWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_show_system_generated = null, $request_staff_ids = null, $request_start_date = null, $request_subtype_ids = null, $request_type_ids = null)
    {
        $returnType = '\Swagger\Client\Model\GetContactLogsResponse';
        $request = $this->clientGetContactLogsRequest($request_client_id, $site_id, $version, $authorization, $request_end_date, $request_limit, $request_offset, $request_show_system_generated, $request_staff_ids, $request_start_date, $request_subtype_ids, $request_type_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetContactLogsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetContactLogsAsync
     *
     * Get contact logs on a client's account.
     *
     * @param  string $request_client_id The ID of the client whose contact logs are being requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters the results to contact logs created before this date.&lt;br /&gt;  Default: **the start date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  bool $request_show_system_generated When &#x60;true&#x60;, system-generated contact logs are returned in the results.&lt;br /&gt;  Default: **false** (optional)
     * @param  int[] $request_staff_ids Filters the results to return contact logs assigned to one or more staff IDs. (optional)
     * @param  \DateTime $request_start_date Filters the results to contact logs created on or after this date.&lt;br /&gt;  Default: **the current date** (optional)
     * @param  int[] $request_subtype_ids Filters the results to contact logs assigned one or more of these subtype IDs. (optional)
     * @param  int[] $request_type_ids Filters the results to contact logs assigned one or more of these type IDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetContactLogsAsync($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_show_system_generated = null, $request_staff_ids = null, $request_start_date = null, $request_subtype_ids = null, $request_type_ids = null)
    {
        return $this->clientGetContactLogsAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization, $request_end_date, $request_limit, $request_offset, $request_show_system_generated, $request_staff_ids, $request_start_date, $request_subtype_ids, $request_type_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetContactLogsAsyncWithHttpInfo
     *
     * Get contact logs on a client's account.
     *
     * @param  string $request_client_id The ID of the client whose contact logs are being requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters the results to contact logs created before this date.&lt;br /&gt;  Default: **the start date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  bool $request_show_system_generated When &#x60;true&#x60;, system-generated contact logs are returned in the results.&lt;br /&gt;  Default: **false** (optional)
     * @param  int[] $request_staff_ids Filters the results to return contact logs assigned to one or more staff IDs. (optional)
     * @param  \DateTime $request_start_date Filters the results to contact logs created on or after this date.&lt;br /&gt;  Default: **the current date** (optional)
     * @param  int[] $request_subtype_ids Filters the results to contact logs assigned one or more of these subtype IDs. (optional)
     * @param  int[] $request_type_ids Filters the results to contact logs assigned one or more of these type IDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetContactLogsAsyncWithHttpInfo($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_show_system_generated = null, $request_staff_ids = null, $request_start_date = null, $request_subtype_ids = null, $request_type_ids = null)
    {
        $returnType = '\Swagger\Client\Model\GetContactLogsResponse';
        $request = $this->clientGetContactLogsRequest($request_client_id, $site_id, $version, $authorization, $request_end_date, $request_limit, $request_offset, $request_show_system_generated, $request_staff_ids, $request_start_date, $request_subtype_ids, $request_type_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetContactLogs'
     *
     * @param  string $request_client_id The ID of the client whose contact logs are being requested. (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  \DateTime $request_end_date Filters the results to contact logs created before this date.&lt;br /&gt;  Default: **the start date** (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     * @param  bool $request_show_system_generated When &#x60;true&#x60;, system-generated contact logs are returned in the results.&lt;br /&gt;  Default: **false** (optional)
     * @param  int[] $request_staff_ids Filters the results to return contact logs assigned to one or more staff IDs. (optional)
     * @param  \DateTime $request_start_date Filters the results to contact logs created on or after this date.&lt;br /&gt;  Default: **the current date** (optional)
     * @param  int[] $request_subtype_ids Filters the results to contact logs assigned one or more of these subtype IDs. (optional)
     * @param  int[] $request_type_ids Filters the results to contact logs assigned one or more of these type IDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetContactLogsRequest($request_client_id, $site_id, $version, $authorization = '', $request_end_date = null, $request_limit = null, $request_offset = null, $request_show_system_generated = null, $request_staff_ids = null, $request_start_date = null, $request_subtype_ids = null, $request_type_ids = null)
    {
        // verify the required parameter 'request_client_id' is set
        if ($request_client_id === null || (is_array($request_client_id) && count($request_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_client_id when calling clientGetContactLogs'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetContactLogs'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetContactLogs'
            );
        }

        $resourcePath = '/public/v{version}/client/contactlogs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_client_id !== null) {
            $queryParams['request.clientId'] = ObjectSerializer::toQueryValue($request_client_id);
        }
        // query params
        if ($request_end_date !== null) {
            $queryParams['request.endDate'] = ObjectSerializer::toQueryValue($request_end_date);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // query params
        if ($request_show_system_generated !== null) {
            $queryParams['request.showSystemGenerated'] = ObjectSerializer::toQueryValue($request_show_system_generated);
        }
        // query params
        if (is_array($request_staff_ids)) {
            $request_staff_ids = ObjectSerializer::serializeCollection($request_staff_ids, 'multi', true);
        }
        if ($request_staff_ids !== null) {
            $queryParams['request.staffIds'] = ObjectSerializer::toQueryValue($request_staff_ids);
        }
        // query params
        if ($request_start_date !== null) {
            $queryParams['request.startDate'] = ObjectSerializer::toQueryValue($request_start_date);
        }
        // query params
        if (is_array($request_subtype_ids)) {
            $request_subtype_ids = ObjectSerializer::serializeCollection($request_subtype_ids, 'multi', true);
        }
        if ($request_subtype_ids !== null) {
            $queryParams['request.subtypeIds'] = ObjectSerializer::toQueryValue($request_subtype_ids);
        }
        // query params
        if (is_array($request_type_ids)) {
            $request_type_ids = ObjectSerializer::serializeCollection($request_type_ids, 'multi', true);
        }
        if ($request_type_ids !== null) {
            $queryParams['request.typeIds'] = ObjectSerializer::toQueryValue($request_type_ids);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetCrossRegionalClientAssociations
     *
     * Get a client's cross regional site associations.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string $request_client_id Looks up the cross regional associations by the client’s ID. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  string $request_email Looks up the cross regional associations by the client’s email address. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetCrossRegionalClientAssociationsResponse
     */
    public function clientGetCrossRegionalClientAssociations($site_id, $version, $authorization = '', $request_client_id = null, $request_email = null, $request_limit = null, $request_offset = null)
    {
        list($response) = $this->clientGetCrossRegionalClientAssociationsWithHttpInfo($site_id, $version, $authorization, $request_client_id, $request_email, $request_limit, $request_offset);
        return $response;
    }

    /**
     * Operation clientGetCrossRegionalClientAssociationsWithHttpInfo
     *
     * Get a client's cross regional site associations.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string $request_client_id Looks up the cross regional associations by the client’s ID. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  string $request_email Looks up the cross regional associations by the client’s email address. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetCrossRegionalClientAssociationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetCrossRegionalClientAssociationsWithHttpInfo($site_id, $version, $authorization = '', $request_client_id = null, $request_email = null, $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetCrossRegionalClientAssociationsResponse';
        $request = $this->clientGetCrossRegionalClientAssociationsRequest($site_id, $version, $authorization, $request_client_id, $request_email, $request_limit, $request_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetCrossRegionalClientAssociationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetCrossRegionalClientAssociationsAsync
     *
     * Get a client's cross regional site associations.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string $request_client_id Looks up the cross regional associations by the client’s ID. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  string $request_email Looks up the cross regional associations by the client’s email address. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetCrossRegionalClientAssociationsAsync($site_id, $version, $authorization = '', $request_client_id = null, $request_email = null, $request_limit = null, $request_offset = null)
    {
        return $this->clientGetCrossRegionalClientAssociationsAsyncWithHttpInfo($site_id, $version, $authorization, $request_client_id, $request_email, $request_limit, $request_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetCrossRegionalClientAssociationsAsyncWithHttpInfo
     *
     * Get a client's cross regional site associations.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string $request_client_id Looks up the cross regional associations by the client’s ID. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  string $request_email Looks up the cross regional associations by the client’s email address. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetCrossRegionalClientAssociationsAsyncWithHttpInfo($site_id, $version, $authorization = '', $request_client_id = null, $request_email = null, $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetCrossRegionalClientAssociationsResponse';
        $request = $this->clientGetCrossRegionalClientAssociationsRequest($site_id, $version, $authorization, $request_client_id, $request_email, $request_limit, $request_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetCrossRegionalClientAssociations'
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  string $request_client_id Looks up the cross regional associations by the client’s ID. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  string $request_email Looks up the cross regional associations by the client’s email address. Either &#x60;ClientId&#x60; or &#x60;Email&#x60; must be provided. If both are provided, the &#x60;ClientId&#x60; is used by default. (optional)
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetCrossRegionalClientAssociationsRequest($site_id, $version, $authorization = '', $request_client_id = null, $request_email = null, $request_limit = null, $request_offset = null)
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetCrossRegionalClientAssociations'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetCrossRegionalClientAssociations'
            );
        }

        $resourcePath = '/public/v{version}/client/crossregionalclientassociations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_client_id !== null) {
            $queryParams['request.clientId'] = ObjectSerializer::toQueryValue($request_client_id);
        }
        // query params
        if ($request_email !== null) {
            $queryParams['request.email'] = ObjectSerializer::toQueryValue($request_email);
        }
        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetCustomClientFields
     *
     * Get a site's configured custom client fields.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetCustomClientFieldsResponse
     */
    public function clientGetCustomClientFields($site_id, $version, $authorization = '', $request_limit = null, $request_offset = null)
    {
        list($response) = $this->clientGetCustomClientFieldsWithHttpInfo($site_id, $version, $authorization, $request_limit, $request_offset);
        return $response;
    }

    /**
     * Operation clientGetCustomClientFieldsWithHttpInfo
     *
     * Get a site's configured custom client fields.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetCustomClientFieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetCustomClientFieldsWithHttpInfo($site_id, $version, $authorization = '', $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetCustomClientFieldsResponse';
        $request = $this->clientGetCustomClientFieldsRequest($site_id, $version, $authorization, $request_limit, $request_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetCustomClientFieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetCustomClientFieldsAsync
     *
     * Get a site's configured custom client fields.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetCustomClientFieldsAsync($site_id, $version, $authorization = '', $request_limit = null, $request_offset = null)
    {
        return $this->clientGetCustomClientFieldsAsyncWithHttpInfo($site_id, $version, $authorization, $request_limit, $request_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetCustomClientFieldsAsyncWithHttpInfo
     *
     * Get a site's configured custom client fields.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetCustomClientFieldsAsyncWithHttpInfo($site_id, $version, $authorization = '', $request_limit = null, $request_offset = null)
    {
        $returnType = '\Swagger\Client\Model\GetCustomClientFieldsResponse';
        $request = $this->clientGetCustomClientFieldsRequest($site_id, $version, $authorization, $request_limit, $request_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetCustomClientFields'
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     * @param  int $request_limit Number of results to include, defaults to 100 (optional)
     * @param  int $request_offset Page offset, defaults to 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetCustomClientFieldsRequest($site_id, $version, $authorization = '', $request_limit = null, $request_offset = null)
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetCustomClientFields'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetCustomClientFields'
            );
        }

        $resourcePath = '/public/v{version}/client/customclientfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_limit !== null) {
            $queryParams['request.limit'] = ObjectSerializer::toQueryValue($request_limit);
        }
        // query params
        if ($request_offset !== null) {
            $queryParams['request.offset'] = ObjectSerializer::toQueryValue($request_offset);
        }
        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientGetRequiredClientFields
     *
     * Get client required fields for a site.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetRequiredClientFieldsResponse
     */
    public function clientGetRequiredClientFields($site_id, $version, $authorization = '')
    {
        list($response) = $this->clientGetRequiredClientFieldsWithHttpInfo($site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientGetRequiredClientFieldsWithHttpInfo
     *
     * Get client required fields for a site.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetRequiredClientFieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientGetRequiredClientFieldsWithHttpInfo($site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\GetRequiredClientFieldsResponse';
        $request = $this->clientGetRequiredClientFieldsRequest($site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetRequiredClientFieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientGetRequiredClientFieldsAsync
     *
     * Get client required fields for a site.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetRequiredClientFieldsAsync($site_id, $version, $authorization = '')
    {
        return $this->clientGetRequiredClientFieldsAsyncWithHttpInfo($site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientGetRequiredClientFieldsAsyncWithHttpInfo
     *
     * Get client required fields for a site.
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientGetRequiredClientFieldsAsyncWithHttpInfo($site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\GetRequiredClientFieldsResponse';
        $request = $this->clientGetRequiredClientFieldsRequest($site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientGetRequiredClientFields'
     *
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientGetRequiredClientFieldsRequest($site_id, $version, $authorization = '')
    {
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientGetRequiredClientFields'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientGetRequiredClientFields'
            );
        }

        $resourcePath = '/public/v{version}/client/requiredclientfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientSendPasswordResetEmail
     *
     * Send a password reset email to a client.
     *
     * @param  \Swagger\Client\Model\SendPasswordResetEmailRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function clientSendPasswordResetEmail($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientSendPasswordResetEmailWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientSendPasswordResetEmailWithHttpInfo
     *
     * Send a password reset email to a client.
     *
     * @param  \Swagger\Client\Model\SendPasswordResetEmailRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientSendPasswordResetEmailWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = 'object';
        $request = $this->clientSendPasswordResetEmailRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientSendPasswordResetEmailAsync
     *
     * Send a password reset email to a client.
     *
     * @param  \Swagger\Client\Model\SendPasswordResetEmailRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientSendPasswordResetEmailAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientSendPasswordResetEmailAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientSendPasswordResetEmailAsyncWithHttpInfo
     *
     * Send a password reset email to a client.
     *
     * @param  \Swagger\Client\Model\SendPasswordResetEmailRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientSendPasswordResetEmailAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = 'object';
        $request = $this->clientSendPasswordResetEmailRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientSendPasswordResetEmail'
     *
     * @param  \Swagger\Client\Model\SendPasswordResetEmailRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientSendPasswordResetEmailRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientSendPasswordResetEmail'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientSendPasswordResetEmail'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientSendPasswordResetEmail'
            );
        }

        $resourcePath = '/public/v{version}/client/sendpasswordresetemail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientUpdateClient
     *
     * Update a client at a site.
     *
     * @param  \Swagger\Client\Model\UpdateClientRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UpdateClientResponse
     */
    public function clientUpdateClient($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientUpdateClientWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientUpdateClientWithHttpInfo
     *
     * Update a client at a site.
     *
     * @param  \Swagger\Client\Model\UpdateClientRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UpdateClientResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientUpdateClientWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UpdateClientResponse';
        $request = $this->clientUpdateClientRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UpdateClientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientUpdateClientAsync
     *
     * Update a client at a site.
     *
     * @param  \Swagger\Client\Model\UpdateClientRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUpdateClientAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientUpdateClientAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientUpdateClientAsyncWithHttpInfo
     *
     * Update a client at a site.
     *
     * @param  \Swagger\Client\Model\UpdateClientRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUpdateClientAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UpdateClientResponse';
        $request = $this->clientUpdateClientRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientUpdateClient'
     *
     * @param  \Swagger\Client\Model\UpdateClientRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientUpdateClientRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientUpdateClient'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientUpdateClient'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientUpdateClient'
            );
        }

        $resourcePath = '/public/v{version}/client/updateclient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientUpdateClientService
     *
     * Update a client's purchase pricing option.
     *
     * @param  \Swagger\Client\Model\UpdateClientServiceRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UpdateClientServiceResponse
     */
    public function clientUpdateClientService($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientUpdateClientServiceWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientUpdateClientServiceWithHttpInfo
     *
     * Update a client's purchase pricing option.
     *
     * @param  \Swagger\Client\Model\UpdateClientServiceRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UpdateClientServiceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientUpdateClientServiceWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UpdateClientServiceResponse';
        $request = $this->clientUpdateClientServiceRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UpdateClientServiceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientUpdateClientServiceAsync
     *
     * Update a client's purchase pricing option.
     *
     * @param  \Swagger\Client\Model\UpdateClientServiceRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUpdateClientServiceAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientUpdateClientServiceAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientUpdateClientServiceAsyncWithHttpInfo
     *
     * Update a client's purchase pricing option.
     *
     * @param  \Swagger\Client\Model\UpdateClientServiceRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUpdateClientServiceAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UpdateClientServiceResponse';
        $request = $this->clientUpdateClientServiceRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientUpdateClientService'
     *
     * @param  \Swagger\Client\Model\UpdateClientServiceRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientUpdateClientServiceRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientUpdateClientService'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientUpdateClientService'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientUpdateClientService'
            );
        }

        $resourcePath = '/public/v{version}/client/updateclientservice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientUpdateClientVisit
     *
     * Update a client's visit.
     *
     * @param  \Swagger\Client\Model\UpdateClientVisitRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UpdateClientVisitResponse
     */
    public function clientUpdateClientVisit($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientUpdateClientVisitWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientUpdateClientVisitWithHttpInfo
     *
     * Update a client's visit.
     *
     * @param  \Swagger\Client\Model\UpdateClientVisitRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UpdateClientVisitResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientUpdateClientVisitWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UpdateClientVisitResponse';
        $request = $this->clientUpdateClientVisitRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UpdateClientVisitResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientUpdateClientVisitAsync
     *
     * Update a client's visit.
     *
     * @param  \Swagger\Client\Model\UpdateClientVisitRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUpdateClientVisitAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientUpdateClientVisitAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientUpdateClientVisitAsyncWithHttpInfo
     *
     * Update a client's visit.
     *
     * @param  \Swagger\Client\Model\UpdateClientVisitRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUpdateClientVisitAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UpdateClientVisitResponse';
        $request = $this->clientUpdateClientVisitRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientUpdateClientVisit'
     *
     * @param  \Swagger\Client\Model\UpdateClientVisitRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientUpdateClientVisitRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientUpdateClientVisit'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientUpdateClientVisit'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientUpdateClientVisit'
            );
        }

        $resourcePath = '/public/v{version}/client/updateclientvisit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientUpdateContactLog
     *
     * Update a contact log on a client's account.
     *
     * @param  \Swagger\Client\Model\UpdateContactLogRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContactLog
     */
    public function clientUpdateContactLog($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientUpdateContactLogWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientUpdateContactLogWithHttpInfo
     *
     * Update a contact log on a client's account.
     *
     * @param  \Swagger\Client\Model\UpdateContactLogRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContactLog, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientUpdateContactLogWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\ContactLog';
        $request = $this->clientUpdateContactLogRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContactLog',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientUpdateContactLogAsync
     *
     * Update a contact log on a client's account.
     *
     * @param  \Swagger\Client\Model\UpdateContactLogRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUpdateContactLogAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientUpdateContactLogAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientUpdateContactLogAsyncWithHttpInfo
     *
     * Update a contact log on a client's account.
     *
     * @param  \Swagger\Client\Model\UpdateContactLogRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUpdateContactLogAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\ContactLog';
        $request = $this->clientUpdateContactLogRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientUpdateContactLog'
     *
     * @param  \Swagger\Client\Model\UpdateContactLogRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientUpdateContactLogRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientUpdateContactLog'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientUpdateContactLog'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientUpdateContactLog'
            );
        }

        $resourcePath = '/public/v{version}/client/updatecontactlog';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientUploadClientDocument
     *
     * Upload a document to a client's profile.
     *
     * @param  \Swagger\Client\Model\UploadClientDocumentRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UploadClientDocumentResponse
     */
    public function clientUploadClientDocument($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientUploadClientDocumentWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientUploadClientDocumentWithHttpInfo
     *
     * Upload a document to a client's profile.
     *
     * @param  \Swagger\Client\Model\UploadClientDocumentRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UploadClientDocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientUploadClientDocumentWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UploadClientDocumentResponse';
        $request = $this->clientUploadClientDocumentRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UploadClientDocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientUploadClientDocumentAsync
     *
     * Upload a document to a client's profile.
     *
     * @param  \Swagger\Client\Model\UploadClientDocumentRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUploadClientDocumentAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientUploadClientDocumentAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientUploadClientDocumentAsyncWithHttpInfo
     *
     * Upload a document to a client's profile.
     *
     * @param  \Swagger\Client\Model\UploadClientDocumentRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUploadClientDocumentAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UploadClientDocumentResponse';
        $request = $this->clientUploadClientDocumentRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientUploadClientDocument'
     *
     * @param  \Swagger\Client\Model\UploadClientDocumentRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientUploadClientDocumentRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientUploadClientDocument'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientUploadClientDocument'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientUploadClientDocument'
            );
        }

        $resourcePath = '/public/v{version}/client/uploadclientdocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientUploadClientPhoto
     *
     * Upload a profile photo to a client's profile.
     *
     * @param  \Swagger\Client\Model\UploadClientPhotoRequest $request request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UploadClientPhotoResponse
     */
    public function clientUploadClientPhoto($request, $site_id, $version, $authorization = '')
    {
        list($response) = $this->clientUploadClientPhotoWithHttpInfo($request, $site_id, $version, $authorization);
        return $response;
    }

    /**
     * Operation clientUploadClientPhotoWithHttpInfo
     *
     * Upload a profile photo to a client's profile.
     *
     * @param  \Swagger\Client\Model\UploadClientPhotoRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UploadClientPhotoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientUploadClientPhotoWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UploadClientPhotoResponse';
        $request = $this->clientUploadClientPhotoRequest($request, $site_id, $version, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UploadClientPhotoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientUploadClientPhotoAsync
     *
     * Upload a profile photo to a client's profile.
     *
     * @param  \Swagger\Client\Model\UploadClientPhotoRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUploadClientPhotoAsync($request, $site_id, $version, $authorization = '')
    {
        return $this->clientUploadClientPhotoAsyncWithHttpInfo($request, $site_id, $version, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientUploadClientPhotoAsyncWithHttpInfo
     *
     * Upload a profile photo to a client's profile.
     *
     * @param  \Swagger\Client\Model\UploadClientPhotoRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientUploadClientPhotoAsyncWithHttpInfo($request, $site_id, $version, $authorization = '')
    {
        $returnType = '\Swagger\Client\Model\UploadClientPhotoResponse';
        $request = $this->clientUploadClientPhotoRequest($request, $site_id, $version, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientUploadClientPhoto'
     *
     * @param  \Swagger\Client\Model\UploadClientPhotoRequest $request (required)
     * @param  string $site_id ID of the site from which to pull data. (required)
     * @param  string $version (required)
     * @param  string $authorization A staff user authorization token. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientUploadClientPhotoRequest($request, $site_id, $version, $authorization = '')
    {
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling clientUploadClientPhoto'
            );
        }
        // verify the required parameter 'site_id' is set
        if ($site_id === null || (is_array($site_id) && count($site_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $site_id when calling clientUploadClientPhoto'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling clientUploadClientPhoto'
            );
        }

        $resourcePath = '/public/v{version}/client/uploadclientphoto';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($site_id !== null) {
            $headerParams['siteId'] = ObjectSerializer::toHeaderValue($site_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
